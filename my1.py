import telebot
from telebot import types
#5336653664:AAHZjXdFcgTDur3CO4iLMNMx7lYbvi-vtws
bot = telebot.TeleBot('5336653664:AAHZjXdFcgTDur3CO4iLMNMx7lYbvi-vtws')

@bot.message_handler(commands=['start'])
def start(message):
    markup = types.ReplyKeyboardMarkup(resize_keyboard = True)
    item1 = types.KeyboardButton('Справочный материал')
    item2 = types.KeyboardButton('Инструменты')
    item3 = types.KeyboardButton('Сайты')

    markup.add(item1, item2, item3)

    bot.send_message(message.chat.id, 'Привет, {0.first_name}! '
                                      'PyBot содержит справочный материал по языку программирования Python,'
                                      ' а также может посоветовать тебе некоторые полезные сайты или инструменты. '
                                      'Что именно тебя интересует?'.format(message.from_user), reply_markup=markup)

@bot.message_handler(content_types=['text'])
def bot_message(message):
    if message.chat.type == 'private':
        if message.text == 'Справочный материал':
            markup = types.ReplyKeyboardMarkup(resize_keyboard = True)
            item1 = types.KeyboardButton('Основы программирования')
            back = types.KeyboardButton('Назад')
            markup.add(item1, back)
            bot.send_message(message.chat.id, 'Справочный материал', reply_markup = markup)

        elif message.text == 'Инструменты':
            bot.send_message(message.chat.id, 'BeeWare' + '\n' + 'https://beeware.org/' + '\n' +
                             'Коллекция инструментов и библиотек для разработки и распространения нативных приложений на Python.'
                             ' Набор инструментов и библиотек помогают разработчикам создавать кросс-платформенные нативные приложения на языке Python'
                             ' с графическим интерфейсом.' + '\n' + '\n' + 'Bottle' + '\n' + 'https://pypi.org/project/bottle/' + '\n' +
                             'Быстрый и простой микро-фреймворк для небольших веб-приложений.' + '\n' + '\n' + 'CherryPi' + '\n' +
                             'https://www.cherrypy.org/' + '\n' + 'Объектно-ориентированный веб-фреймворк на языке Python.'
                             ' Он позволяет разрабатывать веб-приложения аналогично тому, как разрабатываются любые другие ООП-приложения на Python.'  '\n' + '\n' +
                             'Django' + '\n' + 'https://www.djangoproject.com/' + '\n' + 'Высокоуровневый веб-фреймворк на языке Python'
                             ' с открытым исходным кодом поддерживающий быструю разработку и чистый, прагматичный дизайн.'
                             ' Используется для бэкэнда веб-приложений на языке Python.' + '\n' + '\n' + 'Kivy' + '\n' +
                             'https://kivy.org/#home' + 'Библиотека на языке Python с открытым исходным кодом для быстрой'
                             ' разработки приложений, использующих инновации в пользовательском интерфейсе.')

        elif message.text == 'Сайты':
            bot.send_message(message.chat.id, 'Google’s Python Class' + '\n' + 'https://developers.google.com/edu/python/' + '\n' +
                             'Класс Python eBoook от Google считается одним из лучших онлайн-руководств по изучению языка Python.'
                             ' Веб-сайт лучше всего подходит для опытных и опытных учеников. Все концепции Python хорошо написаны и продемонстрированы.'
                             ' В учебниках также используются практические примеры, которые помогут вам глубже понять язык Python.' + '\n' + '\n' +
                             'Python.org' + '\n' + 'https://wiki.python.org/moin/BeginnersGuide' + '\n' +
                             'Сайт содержит официальную документацию по программированию на Python. Вы можете использовать документацию для получения информации о Python. '
                             'В дополнение к документации, Python.org также содержит несколько руководств, которые могут принимать учащиеся через основы Python.'
                             ' Он также охватывает некоторые продвинутые темы, такие как библиотеки и модули Python.' + '\n' + '\n' + 'Code Academy' + '\n' +
                             'https://www.codecademy.com/learn/learn-python' + '\n' + 'Code Academy — это учебный веб-сайт, который предлагает учебные пособия'
                             ' на разных языках программирования. Python — это только один из языков, доступных на этом веб-сайте.'
                             ' Веб-сайт предназначен как для начинающих, так и для промежуточных программистов.' + '\n' + '\n' +
                             'LearnPython.org' + '\n' + 'https://learnpython.org/' + '\n' + 'LearnPython.org — это веб-сайт,'
                             ' на котором вы не только узнаете, как кодировать, но и писать и практиковать код в своем веб-браузере.'
                             ' Он имеет встроенный интерпретатор прямо на веб-сайте, а также учебную серию. Он предоставляет базовые обучающие программы для python.'
                             ' LearnPython также включает упражнения по программированию в конце каждого урока.' + '\n' + '\n' + 'Ideone.com' + '\n' +
                             'https://ideone.com' + '\n' + 'Онлайн компилятор' + '\n' + '\n' + 'Школа программиста' + '\n' +
                             'https://acmp.ru/' + '\n' + 'Образовательный интернет-ресурс олимпиадного программирования для школьников. Позволяет решать задачи '
                             'не только на Python, но и на других языках программирования.')

        elif message.text == 'Назад':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Справочный материал')
            item2 = types.KeyboardButton('Программы')
            item3 = types.KeyboardButton('Сайты')

            markup.add(item1, item2, item3)

            bot.send_message(message.chat.id, 'Назад'.format(message.from_user),
                             reply_markup=markup)

        elif message.text == 'Основы программирования':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Переменные')
            item2 = types.KeyboardButton('Ввод')
            item3 = types.KeyboardButton('Вывод')
            item4 = types.KeyboardButton('Комментарии')
            item5 = types.KeyboardButton('Условный оператор')
            item6 = types.KeyboardButton('Строки (str)')
            item7 = types.KeyboardButton('Операции над числами (int, float)')
            item8 = types.KeyboardButton('Циклы')
            item9 = types.KeyboardButton('Множества (set)')
            item10 = types.KeyboardButton('Классы')
            item11 = types.KeyboardButton('Кортежи')
            item12 = types.KeyboardButton('Списки (list)')
            item13 = types.KeyboardButton('Словари (dict)')

            markup.add(item1, item2, item3, item4, item5, item6, item7, item8, item9, item10,
                       item11, item12, item13)
            bot.send_message(message.chat.id, 'Основы программирования', reply_markup=markup)

        elif message.text == 'Переменные':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Имя переменной должно отражать ее назначение и может состоять из латинских букв, цифр и символа подчеркивания.'
                             ' Имя не может начинаться с цифры.' + '\n'
                             ' Для именования переменных принято использовать слова из маленьких букв с подчеркиваниями.'
                             ' Избегайте использовать такие символы, которые могут не однозначно трактоваться в различных шрифтах:'
                             ' это буква О (большая и маленькая) и цифра 0, буква I (большая и маленькая) и цифра 1. '
                             'Нельзя использовать в качестве имени переменной и ключевые слова, которые существуют в языке.' + '\n'
                             ' Если вы хотите, чтобы у вас была переменная с каким-то именем и каким-то значением, нужно написать на отдельной строчке:'
                             ' <имя переменной> = <значение переменной>' + '\n' +
                             'Пример:' + '\n' + ' bird = "Тук-тук"', reply_markup=markup)

        elif message.text == 'Ввод':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Здесь используется команда input()' + '\n' +
                             'Всегда пишется с круглыми скобками. Команда работает так: ' + '\n' +
                             'когда программа доходит до места, где есть input(), она ждет, пока пользователь введет строку '
                             'с клавиатуры (ввод завершается нажатием клавиши Enter). Введенная строка подставляется на место input().' + '\n' +
                             ' input() получает от пользователя какие-то данные и в место вызова подставляет строковое значение. ' + '\n' +
                             'Если нужно, чтобы пользователь что-то напечатал с клавиатуры и чтобы программа могла использовать эти данные, — пишем input().' + '\n' +
                             'Пример:' + '\n' + ' name = input()', reply_markup=markup)

        elif message.text == 'Вывод':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Для вывода на экран используется команда print()' + '\n' +
                             'Внутри круглых скобок через запятую мы указываем то, что необходимо вывести на экран.'
                             ' Если это какой-то текст, указываем его внутри кавычек.'
                             ' Кавычки могут быть как одинарными, так и двойными.'
                             ' Главное, чтобы текст начинался и заканчивался кавычками одного типа.'
                             ' Команда print записывается только строчными буквами, другое написание недопустимо,'
                             ' так как в Python строчные и заглавные буквы различны.' + '\n' +
                             'Пример:' + '\n' + "print('Привет!')", reply_markup=markup)

        elif message.text == 'Комментарии':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Для удобства можно использовать комментарии, '
                             'которые позволяют программисту делать для себя пометки в коде или делать часть кода не выполнимой,'
                             ' не видимой для интерпретатора.' + '\n' +
                             'Если вы начнете строчку со знака решетки #, интерпретатор Python будет игнорировать всю эту строчку.'
                             ' Программа будет выполняться так, как будто строчки нет. Такая строчка называется комментарием.' + '\n' +
                             'Комментарии нужны в двух случаях:' + '\n' +
                             'Когда нужно добавить в программу какую-то пометку для человека, который будет читать эту программу' + '\n' +
                             'Когда нужно убрать какую-то строчку кода, но удалять ее не хочется (например, потом ее, возможно, понадобится вернуть).'
                             ' Это называется «закомментировать» строчку.', reply_markup=markup)

        elif message.text == 'Условный оператор':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Условный оператор используется, когда некая часть программы должна быть выполнена,'
                             ' только если верно какое-либо условие.' + '\n' + 'Для записи условного оператора используются'
                             ' ключевые слова if и else («если», «иначе»), двоеточие и  отступ в четыре пробела.' +'\n' +
                             'Для сравнения нужно использовать двойной знак равенства: ==.' + '\n' +
                             'Пример:' + '\n' + 'if условие:' + '\n' + "    Действия, если условие верно" + '\n' +
                             'else:' + '\n' + '    Действия, если условие неверно' + '\n' + '\n' +
                             'Сложное условие. Логические операции'
                             'Иногда в условном операторе нужно задать сложное условие. '
                             'Для этого можно использовать логические операции and («и»), or («или») и not («не»).' + '\n' +
                             'Чтобы задать одновременное выполнение двух условий, используем and («и»), '
                             'если достаточно выполнения одного из двух вариантов (или обоих сразу) — используем or («или»), '
                             'а если нужно убрать какой-то вариант — not («не»).', reply_markup=markup)

        elif message.text == 'Строки (str)':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Методы строк')

            markup.add(item1)

            bot.send_message(message.chat.id, 'Строки в Python - упорядоченные последовательности символов,'
                                              ' используемые для хранения и представления текстовой информации.' + '\n' +
                                              'Нумерация символов начинается с 0'
                                              'По индексу можно получить соответствующий ему символ строки.'
                                              ' Для этого нужно после самой строки написать в квадратных скобках индекс символа.' + '\n' +
                                              'Пример:' + '\n' + "word = 'привет'" + '\n' + 'initial_letter = word[0]' + '\n' +
                                              "print(initial_letter)  # сделает то же, что print('п')" + '\n' + "other_letter = word[3]" + '\n' +
                                              "print(other_letter)  # сделает то же, что print('в')" + '\n' + '\n' +
                                              'Кроме «прямой» индексации (начинающейся с 0), в Python разрешены'
                                              ' отрицательные индексы: word[-1] означает последний символ строки word,'
                                              ' word[-2] — предпоследний и т д.'.format(message.from_user), reply_markup=markup)

        elif message.text == 'Методы строк':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Проверка, что подстрока s2 содержится в s:' + '\n' +
                             's2 in s' + '\n' + 'Проверка, что подстрока s2 не содержится в s то же, что not (s2 in s):' + '\n' +
                             'Конкатенация (склейка) строк, то есть строка, в которой сначала идут все символы из s,'
                             ' а затем все символы из s2:' + '\n' + 's + s2' + '\n' + 'Строка s, повторенная k раз:' + '\n' +
                             's * k' + '\n' + 'n-й элемент строки, отрицательные n — для отсчета с конца:' + '\n' +
                             's[n]' + '\n' + 'Срез строки:' + '\n' + 's[start:stop:step]' + '\n' +
                             'Длина строки:' + '\n' + 'len(s)' + '\n' + 'Индекс начала первого или последнего вхождения'
                             ' подстроки s2 в s (вернет -1, если s2 not in s):' + '\n' + 's.find(s2)' + '\n' + 's.rfind(s2)' + '\n' +
                             'Количество неперекрывающихся вхождений s2 в s:' + '\n' + 's.count(s2)' + '\n' +
                             'Проверка, что s начинается с s2 или оканчивается на s2:' + '\n' + 's.startswith(s2)' + '\n' +
                             's.endswith(s2)' + '\n' + 'Заменить содержимое строки на s + s2 и s * k соответственно:' + '\n' +
                             's += s2' + '\n' + 's *= k' + '\n' + 'Проверка, что в строке s все символы — цифры, буквы (включая кириллические), '
                             'цифры или буквы соответственно:' + '\n' + 's.isdigit()' + '\n' + 's.isalpha()' + '\n' + 's.isalnum()' + '\n' +
                             'Проверка, что в строке s не встречаются большие буквы, маленькие буквы. Обратите внимание,'
                             ' что для обеих этих функций знаки препинания и цифры дают True:' + '\n' + 's.islower()' + '\n' +
                             's.isupper()' + '\n' + 'Строка s, в которой все буквы (включая кириллические) приведены к верхнему или нижнему регистру, '
                             'т. е. заменены на строчные (маленькие) или заглавные (большие):' + '\n' + 's.lower()' + '\n' + 's.upper()' + '\n' +
                             'Строка s, в которой первая буква — заглавная:' + '\n' + 's.capitalize()' + '\n' + 'Строка s,'
                             'у которой удалены символы пустого пространства (пробелы, табуляции) в начале, в конце или с обеих сторон:' + '\n' +
                             's.lstrip()' + '\n' +  's.rstrip()' +  '\n' + 's.strip()' + '\n' + 'Добавляет справа или слева нужное количество '
                             'символов c, чтобы длина s достигла k:' + '\n' + 's.ljust(k, c)' + '\n' + 's.rjust(k, c)' + '\n' +
                             'Склеивает строки из списка a через символ s:' + '\n' + 's.join(a)' + '\n' + 'Список всех слов строки s'
                             '(подстрок, разделенных строками s2):' + '\n' + 's.split(s2)' + '\n' + 'Cтрока s, в которой все неперекрывающиеся'
                             'вхождения s2 заменены на s3. Есть необязательный третий параметр, с помощью которого можно указать,'
                             'сколько раз производить замену:' + '\n' + 's.replace(s2, s3)' + '\n' + 'Список символов из строки строки s:' + '\n' +
                             'list(s)' + '\n' + 'Проверка, что строка не пустая (возвращает True, если не пустая, и False в противном случае):' + '\n' +
                             'bool(s)' + '\n' + 'Если в строке s записано целое (дробное) число, получить это число, иначе — ошибка:' + '\n' +
                             'int(s)' + '\n' + 'float(s)' + '\n' + 'Представить любой объект x в виде строки:' + '\n' + 'str(x)', reply_markup=markup)

        elif message.text == 'Операции над числами (int, float)':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                              'Сложение:' + '\n' + 'a + b' + '\n' + 'Вычитание:' + '\n' + 'a - b' + '\n' + 'Умножение:' + '\n' + 'a * b' +
                              'Возведение в степень:' + '\n' + 'a ** b' + '\n' + 'Деление:' + '\n' + 'a / b' + '\n' + 'Целочисленное деление:' + '\n' +
                              'a // b' + '\n' + 'Получение остатка от деления:' + '\n' + 'a % b', reply_markup=markup)

        elif message.text == 'Циклы':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Цикл while')
            item2 = types.KeyboardButton('Цикл for')

            markup.add(item1, item2)

            bot.send_message(message.chat.id, 'Циклы'.format(message.from_user), reply_markup=markup)

        elif message.text == 'Цикл while':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id, 'Выполняет блок кода, пока истинно какое-то условие.' + '\n' + 'Оператор while («пока»)'
                                              ' проверяет условие и в случае его истинности выполняет следующий блок кода (тело цикла).'
                                              ' Однако после выполнения этого блока кода выполняется не то, что идет после него, '
                                              'а снова проверяется условие, записанное после while.' + '\n' +
                                              'while условие:' + '\n' + '    блок кода (тело цикла)', reply_markup=markup)

        elif message.text == 'Цикл for':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Цикл for выполняет блок кода заданное количество раз.' + '\n' + 'for ... in range(...):' + '\n' + '    блок кода (тело цикла)'
                             'В цикле вида for ... in range(...): вместо первого многоточия указывается какая-то переменная,'
                             ' которая на начальной итерации принимает значение 0, на следующей — 1, и так далее, до значения'
                             ' указанного в range(...), само это значение переменная не принимает. Диапазон значений переменной-итератора'
                             ' от 0 включая и до значения, указанного в range(...), не включая его.' + '\n' +
                             'Range означает «диапазон», то есть for i in range(n) читается как «для (всех) i в диапазоне от 0 (включительно)'
                             ' до n (не включительно)...». Цикл выполняется n раз.', reply_markup=markup)

        elif message.text == 'Множества (set)':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Операции над множеством')
            item2 = types.KeyboardButton('Операции над двумя множествами')

            markup.add(item1, item2)

            bot.send_message(message.chat.id,
                             'Множество — составной тип данных, представляющий собой несколько значений (элементов множества)'
                             ' под одним именем. Этот тип называется set. Чтобы задать множество, нужно в фигурных скобках перечислить его элементы.'
                             'Пример:' + '\n' + "mammals = {'cat', 'dog', 'fox', 'elephant'}" + '\n' +
                             'Для создания пустых множеств обязательно вызывать функцию set:' + '\n' + 'empty = set()' + '\n' +
                             'У множеств есть три ключевые особенности:' + '\n' + 'Порядок элементов в множестве не определен' + '\n' +
                             'Элементы множеств — строки и/или числа' + '\n' + 'Множество не может содержать одинаковых элементов'.format(message.from_user), reply_markup=markup)

        elif message.text == 'Операции над множеством':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Вычисление числа элементов множества - len:' + '\n' + "my_set = {'a', 'b', 'c'}" + '\n' + 'n = len(my_set)' + '\n' +
                             'Добавление элемента в множество - add:' + '\n' + "new_elem = 'e'" + '\n' + 'my_set.add(new_elem)' + '\n' +
                             'Для даления элементов есть сразу три метода: discard (удалить заданный элемент, если он есть в множестве,'
                             ' и ничего не делать, если его нет), remove (удалить заданный элемент, если он есть,'
                             ' и породить ошибку KeyError, если нет) и pop. Метод pop удаляет некоторый элемент'
                             ' из множества и возвращает его как результат. Порядок удаления при этом неизвестен. '
                             'Очистить множество от всех элементов можно методом clear.', reply_markup=markup)

        elif message.text == 'Операции над двумя множествами':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Есть четыре операции, которые из двух множеств делают новое множество:'
                             ' объединение, пересечение, разность и симметричная разность.' + '\n' +
                             'Объединение двух множеств включает в себя все элементы, которые есть хотя'
                             ' бы в одном из них. Для этой операции существует метод union:' + '\n' +
                             'union = my_set1.union(my_set2)' + '\n' + 'Или можно использовать оператор |:' + '\n' +
                             'union = my_set1 | my_set2' + '\n' + 'Пересечение двух множеств включает в себя все элементы,'
                             'которые есть в обоих множествах:' + '\n' + 'intersection = my_set1.intersection(my_set2)' + '\n' +
                             'Или аналог:' + '\n' + 'intersection = my_set1 & my_set2' + '\n' + 'Разность двух множеств включает'
                             'в себя все элементы, которые есть в первом множестве, но которых нет во втором:' + '\n' +
                             'diff = my_set1.difference(my_set2)' + '\n' + 'Или аналог:' + '\n' + 'diff = my_set1 - my_set2' + '\n' +
                             'Симметричная разность двух множеств включает в себя все элементы, которые есть только в одном из этих множеств:' + '\n' +
                             'symm_diff = my_set1.symmetric_difference(my_set2)' + '\n' + 'Или аналогичный вариант:' + '\n' + 'symm_diff = my_set1 ^ my_set2', reply_markup=markup)

        elif message.text == 'Кортежи':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Называется tuple. Кортежи очень похожи на списки, они тоже являются индексированной коллекцией,'
                             ' только вместо квадратных в них используются круглые скобки. Как и к строке, к кортежу нельзя добавить'
                             ' элемент методом append, а существующий элемент нельзя изменить, обратившись к нему по индексу. Если списки предназначены'
                             ' скорее для объединения неопределенного количества однородных сущностей, то кортеж — быстрый способ объединить'
                             ' под одним именем несколько разнородных объектов, имеющих различный смысл.', reply_markup=markup)

        elif message.text == 'Списки (list)':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Вложенные списки')
            item2 = types.KeyboardButton('Методы списков')

            markup.add(item1, item2)

            bot.send_message(message.chat.id,
                             'Чтобы задать готовый список, нужно справа от знака присваивания'
                             ' в квадратных скобках перечислить его элементы через запятую. Для того чтобы создать'
                             ' пустой список, можно воспользоваться конструкцией [] или функцией list.' + '\n' +
                             'Индекс отсчитывается с нуля, как в строках. Так же, как и в строках, для нумерации'
                             ' с конца разрешены отрицательные индексы.' + '\n' + 'Во многих языках программирования имеется другой тип данных с похожими'
                             ' свойствами — массив. Поэтому списки иногда называют массивами, хоть это и не совсем правильно. '
                             'Элементы массива имеют одинаковый тип и располагаются в памяти одним куском, а элементы списка могут быть'
                             'разбросаны по памяти как угодно и могут иметь разный тип. Все это замедляет работу списков по сравнению'
                             'с массивами, но придает им гораздо большую гибкость.'.format(message.from_user), reply_markup=markup)

        elif message.text == 'Вложенные списки':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Важно понять, что список списков принципиально ничем не отличается, например, от списка чисел.'
                             ' Чтобы задать список списков в программе, мы также перечисляем элементы через запятую в квадратных скобках:' + '\n' +
                             'table = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]' + '\n' +
                             'Для доступа к элементу списка мы должны указать индекс этого элемента в квадратных скобках.'
                             ' В случае двумерных вложенных списков мы должны указать два индекса (каждый в отдельных квадратных скобках),'
                             ' в случае трехмерного списка — три индекса и т. д. В двумерном случае сначала указывается номер строки,'
                             ' затем — номер столбца (сначала выбирается вложенный список, а затем — элемент из него):' + '\n' +
                             'table = [[1, 2, 3], [4, 5, 6], [7, 8, 9]]' + '\n' + 'print(table[0][0], table[0][1], table[1][0])', reply_markup=markup)

        elif message.text == 'Методы списков':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'Проверка, что x содержится в а:' + '\n' + 'x in a' + '\n' +
                             'Проверка, что x не содержится в а. То же, что и not (x in a):' + '\n' + 'x not in a' + '\n' +
                             'Конкатенация списков, то есть новый список, в котором сначала идут все элементы a, а затем все элементы a2:' + '\n' +
                             'a + a2' + '\n' + 'Список a, повторенный k раз:' + '\n' + 'a * k' + '\n' +
                             'n-й элемент списка, отрицательные n — для отсчета с конца:' + '\n' + 'a[n]' + '\n' +
                             'Срез списка:' + '\n' + 'a[start:stop:step]' + '\n' + 'Длина списка:' + '\n' +
                             'len(a)' + '\n' + 'Максимальный элемент списка:' + '\n' +
                             'max(a)' + '\n' + 'Минимальный элемент списка:' + '\n' + 'min(a)' + '\n' + 'Сумма элементов списка:' + '\n' +
                             'sum(a)' + '\n' + 'Индекс первого вхождения x в a (вызовет ошибку, если x not in a, то есть если х отсутствует в а):' + '\n' +
                             'a.index(x)' + '\n' + 'Количество вхождений x в a:' + '\n' +
                             'a.count(x)' + '\n' + 'Добавить x в конец a:' + '\n' + 'a.append(x)' + '\n' + 'Добавить элементы коллекции a2 в конец a:' + '\n' +
                             'a.extend(a2)' + '\n' + 'Удалить n-й элемент списка:' + '\n' + 'del a[n]' + '\n' + 'Удалить из a все элементы, попавшие в срез:' + '\n' +
                             'del a[start:stop:step]' + '\n' +
                             'Удалить из a все элементы (то же, что del a[:]):' + '\n' + 'a.clear()' + '\n' + 'Копия a (то же, что и полный срез a[:]):' + '\n' +
                             'a.copy()' + '\n' + 'Заменить содержимое списка на a + a2 и a * k соответственно:' + '\n' +
                             'a += a2' + '\n' + 'a *= k' + '\n' + 'Вставить x в a на позицию n, подвинув последующую часть дальше:' + '\n' +
                             'a.insert(n, x)' + '\n' + 'Получить n-й элемент списка и одновременно удалить его из списка. '
                             'Вызов метода без аргументов равносилен удалению последнего элемента:' + '\n' + 'a.pop() == a.pop(-1)' + '\n' + 'a.pop(n)' +
                             '\n' + 'Удалить первое вхождение x в a, в случае x not in a — ошибка:' + '\n' + 'a.remove(x)' + '\n' +
                             'Изменить порядок элементов в a на обратный (перевернуть список):' +
                             '\n' + 'a.reverse()' + '\n' + 'Отсортировать список по возрастанию:' + '\n' + 'a.sort()' +
                             '\n' + 'Отсортировать список по убыванию:' + '\n' + 'a.sort(reverse=True)' + '\n' + 'Один из способов'
                             'проверить список на пустоту (возвращает True, если список непустой, и False в противном случае):' +
                             '\n' + 'bool(a)', reply_markup=markup)

        elif message.text == 'Словари (dict)':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Методы словарей')

            markup.add(item1)

            bot.send_message(message.chat.id, 'Словарь — тип данных, позволяющий, как и список, хранить много данных.'
                                              ' В отличие от списка, в словаре для каждого элемента можно самому определить «индекс»,'
                                              ' по которому он будет доступен. Этот индекс называется ключом.' + '\n' +
                             'Элементы словаря перечисляются в фигурных скобках (как и элементы множества!) и разделяются запятой.'
                             ' До двоеточия указывается ключ, а после двоеточия — значение, доступное в словаре по этому ключу.' + '\n' +
                             'Пустой словарь можно создать двумя способами:' + '\n' + 'd = dict()' + '\n' + '# или так' + '\n' + 'd = {}'.format(
                message.from_user), reply_markup=markup)

        elif message.text == 'Методы словарей':
            markup = types.ReplyKeyboardMarkup(resize_keyboard=True)
            item1 = types.KeyboardButton('Назад')

            markup.add(item1)

            bot.send_message(message.chat.id,
                             'С помощью метода .keys() можно получить список всех ключей словаря:' + '\n' +
                             'actors_names = list(actors.keys())' + '\n' + 'Есть и парный метод .values(), возвращающий все значения словаря:' + '\n' +
                             'all_articles = list(actors.values())' + 'Если вы хотите перебрать элементы словаря d так, чтобы в переменной key'
                             ' оказывался ключ, а в value — соответствующее ему значение, это можно сделать с помощью метода .items() и цикла for:' + '\n' +
                             'for key, val in d.items():', reply_markup=markup)


bot.polling(none_stop = True)